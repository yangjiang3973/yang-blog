[
  {
    "_id": "5e182a2d43daa56f4acbb65b",
    "title": "# 异步编程系列（一）：基本概念",
    "data": "<h1 id=\"\">异步编程系列（一）：基本概念</h1>\n<p>异步编程对于所有的单线程语言都非常重要，这一系列的文章中，代码都会用javascript来举例子，但是其本质也可以运用到其他类似的编程语言，比如Python中。</p>\n<p>实际上，本人第一次接触<code>协程(Coroutine)</code>这个名词还是因为Python，至于大规模的在实际开发中运用，则是因为javascript。因为js本身执行环境是单线程的，如果没有异步编程，每次I/O操作肯定会出现严重的卡顿。</p>\n<h2 id=\"1\">1. 什么是异步</h2>\n<p>你早上起来，习惯先喝杯热水再去洗漱。我们可以抽象两个函数来执行这两个任务：<code>boilWater()</code>，<code>brushTeeth()</code>  </p>\n<p>如果是同步编程，在执行<code>boilWater</code>的时候，你不会去干其他事情，会一直盯着眼前的烧水壶，哪怕还有其他任务等着你。直到水烧开了，当前任务结束，你才会开始接下来的洗漱。</p>\n<p>（叫同步执行可能会有歧义，刚接触的时候容易困惑：不是说同步吗，应该烧水和洗漱一起干啊。但其实这里的“同步”，指的是一个任务连续执行不被打断的意思，而不是同时执行多个任务。）</p>\n<p>聪明的你，为了早上多睡几分钟，肯定会想到，烧水这种事情，完全可以按下开关后就不理它，然后去干别的事情。烧水期间去洗漱，等水烧开了再回来处理。这种不连续执行任务，在任务之间切换（比如烧水和洗漱），就叫做异步编程。</p>\n<h2 id=\"2\">2. 为什么异步很重要</h2>\n<p>在我曾经学习操作系统这门课的时候，了解到两种操作类型：  </p>\n<ol>\n<li>CPU bound</li>\n<li>I/O bound</li>\n</ol>\n<p>如果你要计算精确的π值，这就是CPU bound，属于计算密集型操作，速度取决于你的CPU性能。但是如果你不想自己计算，想从自己的电脑发送一个网络请求，去拿别人计算好的，或者从硬盘里读取特别特别长的π值，这速度就跟CPU没太大关系，属于I/O bound，速度取决于你的网络或者硬盘读取速度。</p>\n<p>如果没有异步编程，一切都是同步的，干完A才能去干B一直到Z。一旦中间有I/O bound操作，整个任务流都会卡住等待当前的读取或者网络请求完成。但是有了异步，在发送完一个网络请求或者文件读取请求后，不用等待，可以接着干其他任务。等请求的结果拿到后，再回来处理之前任务的结果。</p>\n<h2 id=\"3\">3. 常见的异步方案</h2>\n<p>在javascript中，异步I/O方案有很多，常见的有回调函数(callback)，Promise，以及ES6中的async函数。</p>\n<p>先抛开每个方案的具体细节不谈，如果让你来实现异步编程，你觉得最关键的需求在哪里？这就要考虑异步和同步之间的区别：A任务执行的过程中，可以跳到B任务中，在需要的时候，再把执行权还给A任务。你可以把烧水壶的开关打开，紧接着就去刷牙。当水烧开时会“叮“一声通知你，水烧开了，你可以用热水了。这个”叮“一声我们可以理解成callback（喊你回来）。</p>\n<h3 id=\"callback\">Callback</h3>\n<p>callback的原理很直观，你可以进行一个读取文件的操作，当结果返回的时候，就会执行你指定的callback内容。</p>\n<p>callback是以函数的形式来定义未来的操作，决定未来当结果返回后如何处理它，处理的操作都写在callback函数中，然后把callback函数作为参数传给执行I/O操作的函数。</p>\n<pre><code class=\"javascript language-javascript\">let fs = require('fs')\nlet fileA =  fs.readFile('posts/async-porgramming', (err, data) =&gt; {\n    if (err) return err;\n    console.log(data);\n});\n</code></pre>\n<p>如果你觉得上述的读取文件例子不够直观，那我再用烧水壶举个例子：</p>\n<pre><code class=\"javascript language-javascript\">boilWater(coldWater, (err, hotWater) =&gt; {\n    if (err) return err;\n    useHotWater(hotWater);\n    // ..some other code here\n});\n\nwashFace();\nbrushTeeth();\n</code></pre>\n<p>boilWater这个函数的第二个参数，就是callback，当水烧开了，就会调用这个函数。至于怎么使用和处理开水，都定义在callback的函数定义里。在水没烧开前，callback不会执行，而是继续运行下面的代码，开始洗脸刷牙。</p>\n<p>callback虽然理解起来很直观，等之前操作的结果出来了在回去处理。但是它把任务的执行逻辑（boilWater）和处理逻辑（useHotWater）都混在一个函数里，代码稍微有点不够美观。这还是简单的烧水和洗漱，如果更复杂呢？</p>\n<p>假设你可以用冷水洗脸刷牙，但是一定要用热水泡早餐吃的方便面，泡面的几分钟你还要看书，等泡好了再回来吃。</p>\n<pre><code class=\"javascript language-javascript\">boilWater(coldWater, (err, hotWater) =&gt; {\n    if (err) return err;\n    // handle hot water in some other places...\n    // some other code ...\n    cookNoodle(hotWater, noodles, (err, eatableNoodle)=&gt;{\n        if (err) return err;\n        eat(eatableNoodle);\n    })\n    // ..some other code here\n});\n</code></pre>\n<p>为了保证泡面在热水烧开后执行，我们必须把煮面写在boilWater的callback里。因为异步执行的话，写在外面可能会水还没烧开，就执行了煮面的任务。只有在callback里面，才能保证此时烧水完成了，热水准备好了。这样，要求顺序执行的异步任务，就写成了嵌套的函数。如果有三层以上的嵌套，相信我，你写完之后不会再想回来看甚至修改他。而且多层嵌套的callback耦合度极大，简单的说就是牵一发动全身，一动全部都要动。这种代码我相信你一定不想维护，那就一开始写都不要这么写！</p>\n<p>我们先看看问题在哪，分析问题，再去解决。callback方案之所以不友好，主要有两点造成的：1. 执行逻辑（boilWater）和处理逻辑（callback）混在一起提高了耦合度。2. 进一步导致需要顺序执行的异步操作变成了函数多层嵌套，难以阅读。</p>\n<p>为了改进，我们可以先尝试把异步任务的执行逻辑和处理逻辑进行分离。  </p>\n<p>这就是我们下一篇文章要讲的<code>Promise</code>。</p>"
  },

  {
    "_id": "5e182a4943daa56f4acbb65c",
    "title": "# 异步编程系列（二）：Promise",
    "data": "<h1 id=\"promise\">异步编程系列（二）：Promise</h1>\n<p>上一篇文章介绍了异步编程的基本概念，以及最常见的callback方案。 </p>\n<p>但是在复杂的开发项目中，callback本身的缺点会被放大，多重嵌套的callback会导致<code>callback hell(回调地狱)</code>。听这个名字就很吓人，导致的结果确实也让项目代码变得极难维护。为了避免callback的缺陷，同时继续利用异步的好处，我们来看下Promise这个异步方法。</p>\n<h2 id=\"\">基本用法</h2>\n<p>最早的时候，Promise有很多不同的libiary，有名的比如<code>when</code>,<code>Q</code>这些,后来ES6把Promise已经写进了其标准中，所以Promise的用法已经统一了。</p>\n<p>Promise的构造函数接受一个函数定义作为参数，这个函数的格式要求有两个参数，resolve和reject。从这个角度看，我们可以把Promise当做封装异步操作的容器。</p>\n<p>在这个被包装的函数里，你可以把异步操作封装进去，然后分别处理将来成功返回或者失败的结果。顾名思义，resolve就是成功情况下运行，reject则是失败时被call。</p>\n<p>这样，我们就可以把未来如何处理返回后的结果的逻辑，成功的与执行逻辑分开了。执行逻辑被封装进promise容器中，处理逻辑可以写进promise的then()方法里。返回的结果，成功了就作为参数传进resolve函数里。</p>\n<p>在then方法里，我们可以详细定义如何处理返回的结果。它接受两个回调函数作为参数，第一个是为resolve准备的，传进resolve的参数，也就是异步操作的成功结果，可以在这里进行处理。第二个回调函数是为reject准备的，但是属于optional，可以放在这里，也可以用稍后介绍的另一种形式处理异步的错误。</p>\n<pre><code class=\"javascript language-javascript\">let myPromise = new Promise((resolve, reject) =&gt; {\n  // maybe do an async thing here, such as boilWater() \n  boilWater();\n\n  if (/* everything is sucessful */) {\n    resolve(\"hot water is ready!\");\n  }\n  else {\n    reject(Error(\"It broke\"));\n  }\n});\n\nmyPromise.then((result) =&gt; {\n    console.log(result);  // output: hot water is ready \n}, (err) =&gt; {\n    console.log(err);\n});\n</code></pre>\n<p>通常情况下，我们不会把处理错误的逻辑也写在then方法里，而是用promise.catch。其实就是把then的第二个参数，移动到了catch里，这样是不是更清晰了。  </p>\n<pre><code class=\"javascript language-javascript\">promise\n  .then(result =&gt; { \n    console.log(result);\n  })\n  .catch(err =&gt; {\n    console.log(err);\n  });\n</code></pre>\n<p>一个常见的用法就是用Promise封装Ajax的异步操作：</p>\n<pre><code class=\"javascript language-javascript\">function get(url) {\n  // Return a new promise obj.\n  return new Promise((resolve, reject) =&gt; {\n    var req = new XMLHttpRequest();\n    req.open('GET', url);\n\n    req.onreadystatechange = function() {\n        if (req.readyState === 4) {\n            if (req.status === 200) {\n                // Pass the result to resolve to handle\n                resolve(req.response);\n            }\n            else {\n                reject(Error(req.statusText));\n            }\n        }\n    };\n\n    // Handle network errors\n    req.onerror = function() {\n      reject(Error(\"Network Error\"));\n    };\n\n    // Make the request\n    req.send();\n  });\n}\n\n// run get(url)\nget('somedata.json').then((response) =&gt; {\n  console.log(\"Success!\", response);\n}).catch((err) =&gt; {\n    console.log(\"Fail!\", err);\n});\n</code></pre>\n<h2 id=\"-1\">链式调用</h2>\n<p>之前我们在callback的用法里讲到，一组异步操作如果要顺序执行，就要在callback里嵌套后续任务代码。在这个问题上，Promise比起callback的优点在于支持链式(chaining)写法，避免了多重嵌套。then()方法会返回一个新的promise对象，所以then后面可以继续then。前者返回的结果，还是会作为参数传进下一个回调函数中。</p>\n<p>比如我们有一个json文件（fileList.json），里面存有一系列文件名和其他数据，我们想要打开第一个文件，就要先打开fileList，得到第一个文件名，再去读取该文件。这是一个典型的要求顺序操作的异步任务流程。</p>\n<pre><code class=\"javascript language-javascript\">readJSON('fileList.json')\n.then(function(data) {\n  return readJSON(data.fileName[0]);\n})\n.then(function(file) {\n  console.log(\"Got file!\", file);\n})\n</code></pre>\n<p>因为promise把执行逻辑和处理逻辑分开了，所以我们就避免了之前的callback嵌套，代码变成了链式，看起来更直观。</p>\n<h2 id=\"-2\">并行执行</h2>\n<p>上述链式调用可以用在需要顺序操作的异步任务中，将任务给串联起来。但是有些任务可以并联起来，比如烧热水和洗衣服，这就可以用promise.all()来同时开启任务。</p>\n<pre><code class=\"javascript language-javascript\">let p1 = new Promise((resolve, reject) =&gt; {\n    // your code to boil water\n});\nlet p2 = new Promise((resolve, reject) =&gt; {\n    // your code to do the laundry\n});\n\nPromise.all([p1, p2]).then( (results) =&gt; {  // results is an array of returned result\n    console.log(results);  \n});\n</code></pre>\n<p>将要并行执行的任务写进数组传给Promise.all()，返回的的结果也会包装进数组作为参数传给resolve函数。</p>\n<p>但是all()方法中的任务是AND关系，只有所有的promise都返回了，才会执行then()。如果你想把任务变成OR关系，有一个返回就立即执行then，可以用Promise.race()方法。</p>\n<p>总之，Promise还有许多强大的功能，这里只是简单的介绍，如果感兴趣的话可以去搜搜它的API reference。</p>"
  },

  {
    "_id": "5e182a5b43daa56f4acbb65d",
    "title": "# 异步编程系列（三）：从Generator到Async",
    "data": "<h1 id=\"generatorasync\">异步编程系列（三）：从Generator到Async</h1>\n<h2 id=\"1\">1. 概览</h2>\n<p>从callback到promise，我们可以看到，异步编程的代码逻辑变得更像同步编程的代码，实现了执行异步函数和处理返回结果的分离。但是promise虽然做到了这一点，但是为代码引入了很多promise独有的API，反而模糊了真正的业务代码。我们要先封装进promise中，返回promise对象，再通过then()方法处理结果。</p>\n<pre><code class=\"javascript language-javascript\">function printString(string){\n  return new Promise((resolve, reject) =&gt; {\n    setTimeout(\n      () =&gt; {\n       console.log(string);\n       resolve();\n      }, \n     Math.floor(Math.random() * 100) + 1;\n    )\n  })\n}\n\nfunction printAll(){\n  printString(\"A\")\n  .then(() =&gt; printString(\"B\")\n  )\n  .then(() =&gt;  printString(\"C\")\n  )\n}\nprintAll();\n</code></pre>\n<p>从上述代码可以发现，想要顺序输出“ABC”三个字符，先要把异步操作封装进一个promise对象里，再链式调用promise的then()方法。有没有更贴近原生javascript代码的语法呢？</p>\n<p>ES2017里引入了新的语法async/await，让异步代码更简洁更贴近原生js代码的样子，并且能和promise无缝配合。</p>\n<pre><code class=\"javascript language-javascript\">async function printAll(){\n  await printString(\"A\")\n  await printString(\"B\")\n  await printString(\"C\")\n}\nprintAll();\n</code></pre>\n<p>用async和await替换掉promise的api，是不是代码看起来更像同步代码，易读性大大提高！</p>\n<h2 id=\"2generator\">2. Generator</h2>\n<p>async/await的使用本身，并没有什么好讲的，用法已经直观。但是更让人好奇的是他们的底层原理，如何做到让代码本身接近js原生的同步代码写法，但是能运行异步操作，同时又隐藏了Promise的API。虽然这种说法不够准确，但是从一定程度上说，async/await算是generator的语法糖。</p>\n<p>我们先来看看generator到底是怎么用于异步编程的。</p>\n<p>回到我们第一篇文章讲的异步编程的基本概念，要想实现异步执行，我们要能够开始执行某异步任务（函数A）后，跳出该任务，将执行权赋予其他任务（函数B），在执行期间等待之前的异步任务返回结果。知道时机成熟再跳回去继续处理，恢复异步任务（函数A）的执行权。</p>\n<p>这就需要原本的同步代码中的函数，可以在执行过程中，启动-&gt;暂停-&gt;恢复。而<code>Generator</code>就是这样一个能够让我们控制函数执行的特殊函数。</p>\n<pre><code class=\"javascript language-javascript\">function* stateMachine() {\n    yield \"state A\";\n    yield \"state B\";\n    return \"state end\";\n}\n\nlet g = stateMachine();  \nconsole.log(g);  // Object [Generator] {}\nlet r1 = g.next();\nconsole.log(r1);  // { value: 'state A', done: false }\nlet r2 = g.next();\nconsole.log(r2);  // { value: 'state B', done: false }\nlet r3 = g.next();\nconsole.log(r3);  // { value: 'state end', done: true }\n</code></pre>\n<p>习惯一般函数的人，第一次看generator函数的语法如果觉得难以理解，可以把它看成一个手动控制的状态机。</p>\n<p>上述代码中，这个状态机有三个状态：A，B，end。</p>\n<pre><code class=\"javascript language-javascript\">let g = stateMachine();\n</code></pre>\n<p>只是对状态机进行了初始化，并没有开始运行，所以返回的只是一个generator对象。</p>\n<p>接着，我们第一次call next()方法进入第一个状态A（yield右边的表达式就是一个状态）。该状态会返回给next()方法，所以r1输出<code>{ value: 'state A', done: false }</code>（第一个值是当前返回的状态，第二个值表面状态机有没有跑完）。此时状态机会停留在该状态，你可以在此期间做其他事情，直到你手动第二次call next()方法，状态机才会进入下一个状态B，将此时状态返回给next。因为这个状态机只有三个状态，到最后返回的内容变为<code>{ value: 'state end', done: true }</code>（第二个值变为true，显示结束）。</p>\n<p>一个只有输出，不接受输入的状态机，不是好状态机。上面的例子，只能暂停返回某一阶段状态，而不能在下一阶段重启时接受外界的输入。想要输入数据，这就需要将next()方法增加一个参数，参数将数据传递进去。</p>\n<pre><code class=\"javascript language-javascript\"> function* stateMachine() {\n    const resumeAfterA = yield \"state A\";\n    console.log(resumeAfterA);\n    const resumeAfterB =  yield \"state B\";\n    console.log(resumeAfterB);\n    return \"state end\";\n}\n\nlet g = stateMachine();  \nlet r1 = g.next();\nconsole.log(r1);\nlet r2 = g.next(\"continue after state A\");\nconsole.log(r2);\nlet r3 = g.next(\"continue after state B\");\nconsole.log(r3);\n\n/*\noutput:\n{value: 'state A', done: false}\ncontinue after state A\n{value: 'state B', done: false}\ncontinue after state B\n{value: 'state end', done: true}\n*/\n</code></pre>\n<p>因为第一个next()是负责启动的，在这之前还没有开始执行，所以不传入数据。函数执行到第一个yield停止，并将右侧的表达式返回给此next()。</p>\n<p>从第二个next开始，可以将在新一轮状态开始前，用参数将数据传进去。它会替换掉上一轮的状态，变成参数的值。<code>yield \"state A\"</code>会替换成<code>\"continue after state A\"</code>，然后赋予给变量resumeAfterA，然后继续开始往下执行，直到下一个yield。</p>\n<p>这也容易从状态机的角度理解。因为上一轮的状态已经返回出来了(\"state A\")，所以重新开始下一轮的时候，已经不需要之前跑过的状态了，所以可以用新的输入(\"continue after A\")<strong><em>替换</em></strong>掉旧状态，然后开始下一回合，到下一个yield再暂停并返回此时状态。</p>\n<p>这就是一个可以有输入和输出的有限状态机，我们可以手动控制它何时进入下一个状态，达到了随时执行/暂停的效果。似乎已经满足了之前异步执行任务（函数）的要求。</p>\n<h2 id=\"coroutine\">协程（Coroutine）</h2>\n<p>简单概括协程，就是函数在执行过程中，随时可以暂停，并把执行权交给其他函数。等到时机成熟，又可以拿回执行权继续恢复运行。</p>\n<p>有了generator，我们就可以协程起来，即使在单线程的限制下，也可以做到并发。</p>\n<p><code>fs.readdir</code>是一个异步读取文件夹下文件的操作，我们将它封装到generator中。</p>\n<pre><code class=\"javascript language-javascript\">const fs = require('fs');\n\nfunction* read(path) {\n    const dirData = yield function(callback) {\n        fs.readdir(path, callback);\n    };\n    console.log(dirData);\n}\n\n// execute\nlet gen = read('[your path of dir]');\n\nlet start = gen.next();\n\nstart.value((err, dir) =&gt; {\n    gen.next(dir);\n});\n\n// do some other tasks while waiting \nconsole.log('other tasks');\n\n/* output:\nother tasks\n\n[your dir info]\n*/\n</code></pre>\n<p>但是你肯定不想手动控制暂停/执行，尤其在多有个yield的情况下，那就需要我们有一个自动控制状态机的控制机。我们可以递归式的在callback里call next，这样就实现了generator的自动执行。你可以自己写一个，也可以用现成的模块，比如<code>co</code>。本质上都是，当异步操作的结果返回了，能再把控制权交还给之前的函数，继续下一步的执行。</p>\n<h2 id=\"asyncawait\">async/await</h2>\n<p>为什么之前说，async是generator的语法糖这种说法，很形象但不准确，因为如果仅仅是generator，它无法自动执行。所以async不单单是代码语法的替换，把星号换成async，yield换成await，也自带了一个自动执行功能。你既可以充分利用generator的异步功能，也可以像写同步代码一样进行异步编程，</p>\n<p>之前我们要用<code>function* ()</code>来声明这是一个generator，现在换成了<code>async function ()</code>,表明有异步操作。<code>await</code>后面的表达式，则是需要执行后等待结果返回，可以是promise类型或者原始类型。如果是promise，就返回异步的结果，如果不是promise，就直接返回表达式的值。</p>\n<p>通常情况下，要把异步操作放到<code>try...catch...</code>语句中，这样有了错误可以被捕捉到。</p>\n<pre><code class=\"javascript language-javascript\">async function manyTasks() {\n  try {\n    const val1 = await taskA();\n    const val2 = await taskB();\n  }\n  catch (err) {\n    console.error(err);\n  }\n}\n</code></pre>\n<p>有了async/await，我们就可以，以同步代码的形式，写出异步的操作，可维护性比callback大大提升。假设我们用async来进行ajax call，request函数已经对ajax call的细节进行了封装，我们知道它是一个异步操作。</p>\n<pre><code class=\"javascript language-javascript\">async function doSomeRequests() {\n    var result1 = await request( \"http://some.url.1\" );\n    var data = JSON.parse( result1 );\n\n    var result2 = await request( \"http://some.url.2?id=\" + data.id );\n    var resp = JSON.parse( result2 );\n    console.log( \"The value you asked for: \" + resp.value );\n}\n\ndoSomeRequests();\n</code></pre>\n<p>是不是看起来，比起各种嵌套的callback清晰的多了。</p>"
  }
]
