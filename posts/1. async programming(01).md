<!-- 异步编程系列（一）：基本概念 -->

异步编程对于所有的单线程语言都非常重要，这一系列的文章中，代码都会用 javascript 来举例子，但是其本质也可以运用到其他类似的编程语言，比如 Python 中。

实际上，本人第一次接触`协程(Coroutine)`这个名词还是因为 Python，至于大规模的在实际开发中运用，则是因为 javascript。因为 js 本身执行环境是单线程的，如果没有异步编程，每次 I/O 操作肯定会出现严重的卡顿。

## 1. 什么是异步

你早上起来，习惯先喝杯热水再去洗漱。我们可以抽象两个函数来执行这两个任务：`boilWater()`，`brushTeeth()`

如果是同步编程，在执行`boilWater`的时候，你不会去干其他事情，会一直盯着眼前的烧水壶，哪怕还有其他任务等着你。直到水烧开了，当前任务结束，你才会开始接下来的洗漱。

（叫同步执行可能会有歧义，刚接触的时候容易困惑：不是说同步吗，应该烧水和洗漱一起干啊。但其实这里的“同步”，指的是一个任务连续执行不被打断的意思，而不是同时执行多个任务。）

聪明的你，为了早上多睡几分钟，肯定会想到，烧水这种事情，完全可以按下开关后就不理它，然后去干别的事情。烧水期间去洗漱，等水烧开了再回来处理。这种不连续执行任务，在任务之间切换（比如烧水和洗漱），就叫做异步编程。

## 2. 为什么异步很重要

在我曾经学习操作系统这门课的时候，了解到两种操作类型：

    1. CPU bound
    2. I/O bound

如果你要计算精确的 π 值，这就是 CPU bound，属于计算密集型操作，速度取决于你的 CPU 性能。但是如果你不想自己计算，想从自己的电脑发送一个网络请求，去拿别人计算好的，或者从硬盘里读取特别特别长的 π 值，这速度就跟 CPU 没太大关系，属于 I/O bound，速度取决于你的网络或者硬盘读取速度。

如果没有异步编程，一切都是同步的，干完 A 才能去干 B 一直到 Z。一旦中间有 I/O bound 操作，整个任务流都会卡住等待当前的读取或者网络请求完成。但是有了异步，在发送完一个网络请求或者文件读取请求后，不用等待，可以接着干其他任务。等请求的结果拿到后，再回来处理之前任务的结果。

## 3. 常见的异步方案

在 javascript 中，异步 I/O 方案有很多，常见的有回调函数(callback)，Promise，以及 ES6 中的 async 函数。

先抛开每个方案的具体细节不谈，如果让你来实现异步编程，你觉得最关键的需求在哪里？这就要考虑异步和同步之间的区别：A 任务执行的过程中，可以跳到 B 任务中，在需要的时候，再把执行权还给 A 任务。你可以把烧水壶的开关打开，紧接着就去刷牙。当水烧开时会“叮“一声通知你，水烧开了，你可以用热水了。这个”叮“一声我们可以理解成 callback（喊你回来）。

### Callback

callback 的原理很直观，你可以进行一个读取文件的操作，当结果返回的时候，就会执行你指定的 callback 内容。

callback 是以函数的形式来定义未来的操作，决定未来当结果返回后如何处理它，处理的操作都写在 callback 函数中，然后把 callback 函数作为参数传给执行 I/O 操作的函数。

```javascript
let fs = require('fs');

let fileA = fs.readFile('posts/async-porgramming', (err, data) => {
    if (err) return err;
    console.log(data);
});
```

如果你觉得上述的读取文件例子不够直观，那我再用烧水壶举个例子：

```javascript
boilWater(coldWater, (err, hotWater) => {
    if (err) return err;
    useHotWater(hotWater);
    // ..some other code here
});

washFace();
brushTeeth();
```

boilWater 这个函数的第二个参数，就是 callback，当水烧开了，就会调用这个函数。至于怎么使用和处理开水，都定义在 callback 的函数定义里。在水没烧开前，callback 不会执行，而是继续运行下面的代码，开始洗脸刷牙。

callback 虽然理解起来很直观，等之前操作的结果出来了在回去处理。但是它把任务的执行逻辑（boilWater）和处理逻辑（useHotWater）都混在一个函数里，代码稍微有点不够美观。这还是简单的烧水和洗漱，如果更复杂呢？

假设你可以用冷水洗脸刷牙，但是一定要用热水泡早餐吃的方便面，泡面的几分钟你还要看书，等泡好了再回来吃。

```javascript
boilWater(coldWater, (err, hotWater) => {
    if (err) return err;
    // handle hot water in some other places...
    // some other code ...
    cookNoodle(hotWater, noodles, (err, eatableNoodle) => {
        if (err) return err;
        eat(eatableNoodle);
    });
    // ..some other code here
});
```

为了保证泡面在热水烧开后执行，我们必须把煮面写在 boilWater 的 callback 里。因为异步执行的话，写在外面可能会水还没烧开，就执行了煮面的任务。只有在 callback 里面，才能保证此时烧水完成了，热水准备好了。这样，要求顺序执行的异步任务，就写成了嵌套的函数。如果有三层以上的嵌套，相信我，你写完之后不会再想回来看甚至修改他。而且多层嵌套的 callback 耦合度极大，简单的说就是牵一发动全身，一动全部都要动。这种代码我相信你一定不想维护，那就一开始写都不要这么写！

我们先看看问题在哪，分析问题，再去解决。callback 方案之所以不友好，主要有两点造成的：1. 执行逻辑（boilWater）和处理逻辑（callback）混在一起提高了耦合度。2. 进一步导致需要顺序执行的异步操作变成了函数多层嵌套，难以阅读。

为了改进，我们可以先尝试把异步任务的执行逻辑和处理逻辑进行分离。

这就是我们下一篇文章要讲的`Promise`。
